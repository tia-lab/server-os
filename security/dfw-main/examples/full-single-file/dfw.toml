# Below you'll find an example configuration, showing you and explaining most
# (if not all) possible configurations you might need. If you are unsure about
# any of the explanations, be sure to also check out the documentation on the
# internal types that are configured through this TOML file:
#
#   https://docs.rs/dfw/*/dfw/types/index.html
#
# Each of the sections in this file matches to a struct under the same name,
# and every struct field contains some documentation that might help you out.

[global_defaults]
# Define the external network interface(s) that the Docker networks should be
# able to communicate with. (You can also skip this key, or specify it as a
# list of strings if you have multiple interfaces.)
external_network_interfaces = "eth0"
# This setting controls whether the default Docker bridge (usually `docker0`) is
# allowed to access host resources. Non-default bridges are managed through the
# container-to-host section. The default is to accept traffic.
# You can specify "accept" or "drop".
default_docker_bridge_to_host_policy = "accept"

[backend_defaults]
# If you are already using nftables or are running a default nftables
# installation, chances are that you already have nftables table called
# "filter". For DFW to work correctly it is necessary to provide the existing
# tables and the names of their input and forward chains such that it can hook
# into them, ensuring that the traffic managed by DFW is correctly accepted or
# denied. (If you have multiple pre-existing tables, you can specify a list
# here, too.)
# The following is a sane default that should work for most setups.
custom_tables = { name = "filter", chains = ["input", "forward"] }

[backend_defaults.initialization]
# The backend-defaults table allows you to define any commands that you want
# executed against nftables when DFW applies the ruleset, in addition to the
# rules generated by DFW itself.
rules = [
    "add table inet custom",
    "flush table inet custom",
    # ...
]

[container_to_container]
# The container_to_container table defines if and how containers are allowed to
# communicate amongst each other. The first thing you have to define is the
# default policy that should be applied to C2C communication, e.g. disallow all
# communication by default: (valid values are "accept" and "drop")
default_policy = "drop"

[[container_to_container.rules]]
# To then allow specific communication between containers, you'll have to add a
# rule defining this communication. For example the following configuration
# will allow all communication between the containers `container_a` and
# `container_b`, as long as the containers are able to communicate via the
# Docker network `common_network`.
network = "common_network"
src_container = "container_a"
dst_container = "container_b"
verdict = "accept"
# (If you want to enable communication between two containers that are on
# separate Docker networks, check out the container_dnat section at the end of
# the file.)

[[container_to_container.rules]]
# The `src_container` and `dst_container` fields are both optional, and you are
# allowed to specify both, none, or either one. This enables you to for example
# configure the allowed communication on a complete Docker network, no matter
# the containers involved:
network = "internal_network"
verdict = "accept"

[[container_to_container.rules]]
# Being able to specify only one of `src_container` and `dst_container` can be
# useful in many cases. One example could be a reverse-proxy: you want your
# proxying container to be able to access any other container on the same
# reverse-proxy network, without the other containers being able to access each
# other or the proxying container (except for the responses to requests made by
# the reverse proxy, i.e. related and established traffic will be allowed):
network = "reverseproxy_network"
src_container = "my_reverseproxy"
verdict = "accept"

[[container_to_container.rules]]
# If the simple iptables actions (accept, reject, drop) are not enough for your
# use-case, you can also specify the `matches` field which will add your
# specified string to the iptables command executed. This enables you to for
# example set a specific destination port that should be reachable, rather than
# the container as a whole:
network = "reverseproxy_network"
src_container = "my_reverseproxy"
dst_container = "my_webserver"
matches = "tcp dport 8080"
verdict = "accept"

[container_to_wider_world]
# The container_to_wider_world table defines if and how containers should be
# able to communicate with the wider world. (Communications with the host are
# handled separately, see the next section.) This table expects a default
# policy, i.e. if you want to allow or block traffic to the wider world by
# default. If your containers should be able to reach the internet, you'll
# probably want to set this to "accept".
default_policy = "accept"

[[container_to_wider_world.rules]]
# The container_to_wider_world rules work very similar to the
# container_to_container ones, except for one major change: there is no
# destination container, but rather the external network interface the source
# network/container should be able to communicate with. So if you want to e.g.
# block a specific Docker network from accessing resources on `eth0`, you can
# do this:
network = "internal_network"
verdict = "reject"
external_network_interface = "eth0"

[[container_to_wider_world.rules]]
# If you don't define the `external_network_interface`, DFW will by default use
# the (first) external network interface you have defined in the "defaults"
# section of this config, in this case `eth0`. This means that the following
# rule is identical to the one above:
network = "internal_network"
verdict = "reject"

# Note: you are also free to specify the `src_container` and `filter` fields
# here. Their behaviour is identical to what was shown for the
# container-to-container rules.

[container_to_host]
# The container_to_host table lets you configure if you want your containers to
# be able to communicate with the Docker host itself or not. Again, we expect a
# default policy:
default_policy = "accept"

[[container_to_host.rules]]
# And as with container_to_container and container_to_wider_world before, you
# can specify additional rules. You are required to provide the `network` and
# `action` keys, and are allowed to also specify the `src_container` and an
# additional `matches`, as with the other types of rules, too.
network = "internal_network"
verdict = "reject"

[wider_world_to_container]
# The last section you'll probably need -- and this is maybe the most important
# one -- is wider_world_to_container. This allows you to specify what resources
# the wider world should be able to access from your Docker containers, i.e.
# allowing connections to the ports and thus services running in your Docker
# containers. This section does NOT allow you to specify a default policy, it
# is expected that you manually allow all services you require.

[[wider_world_to_container.rules]]
# To configure access to some resource from the wider world, you'll need to
# specify the Docker network and container that should be accessible.
# Furthermore you need to specify the port that the service in the container
# listens to, as well as the port that should be used to publish this service
# on the host.
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = { host_port = 80, container_port = 80, family = "tcp" }

# Specifying the port like this is relatively long-winded, especially if the
# host and container port are identical. To work around this, you have multiple
# other methods of doing the same thing (from least verbose to most verbose):
#
#   expose_port = 80
#   expose_port = "80/tcp"
#   expose_port = { host_port = 80 }
#   expose_port = { host_port = 80, family = "tcp" }
#   expose_port = { host_port = 80, container_port = 80 }
#   expose_port = { host_port = 80, container_port = 80, family = "tcp" }
#
# All of these are identical, where the `family` is by default assumed to be
# TCP, and the container port is assumed to be identical to the host port.

[[wider_world_to_container.rules]]
# Sometimes, you might also want to allow access to multiple ports from a
# single container. This is also possible:
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = [80, 443]

# If the container ports are different from the host ports, you can still
# define multiple at once:
#
#   expose_port = [
#       { host_port = 80, container_port = 8080 },
#       { host_port = 443, container_port = 80443 },
#   ]

[[wider_world_to_container.rules]]
# A final thing: the WW2C rules require the external network interface to be
# specified, for which the host-port will be forwarded to the container. By
# default this is again the primary (i.e. the first) external network interface
# as specified in the "defaults" section, but you can override this here:
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = [80, 443]
external_network_interface = "tun0"

[container_dnat]
# Finally, the actual last section and one you might only need in very special
# cases, is container_dnat. This section allows you to prohibit or allow
# communication between containers that DO NOT share a Docker network. (There
# is no default policy.)

[[container_dnat.rules]]
# You can use this section to for example allow any container to access some
# central container, like a log-collection target. (This rule shows all
# required fields.)
dst_network = "log_network"
dst_container = "logstash"
expose_port = 5044

[[container_dnat.rules]]
# Alternatively you can specify that one specific container can access another
# specific container, across networks. (This rule shows all fields, including
# optional ones.)
src_network = "network_a"
src_container = "container_a"
dst_network = "network_b"
dst_container = "container_b"
expose_port = "50000/udp"
